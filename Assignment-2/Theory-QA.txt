1. 
NPM:(unofficially abbreviated as Node Package Manager)
It is a package manager for Node.js 
It is a command line utility that helps in installing, updating, and managing libraries or tools (called “packages” or “modules”) in the projects.
It includes a built-in audit feature (npm audit) to check for and fix security vulnerabilities in project dependencies.

2.
Parcel/Webpack are both module bundlers which are tools that help you manage, optimize and bundle your javascript files for web applications.
These bundlers combine all these files into a single optimized file for the browser.
They also handle tree-shaking (removing unused code) and code-splitting (loading only what’s needed).
Bundlers can process not just Javascript, but also CSS, images, fonts and more.
3. 
The .parcel-cache directory is automatically created by Parcel when you build or run your project. It serves as a cached folder to speed up subsequent builds and improve performance.
Parcel caches processed files (JavaScript, CSS, images, etc.) so it doesn’t reprocess them unnecessarily. This significantly speeds up rebuilds when you make changes to your code.
This folder can also be deleted, parcel will regenerate the folder back on the next build.
This caching can also be disabled by adding the flag --no-cache in the build command.

4.
NPX is a command line tool that comes with npm(from the version 5.2), which is designed to make it easier to run the Node.js packages without installing them globally and to avoid version conflicts.

5.
dependencies:
Packages listed here are required for the application to run in production.
These are included when deploying.
Eg: react, express.
devDependencies:
Packages listed here are only required for development and testing.
These packages are excluded in production builds.
While installing these dependencies a flag -D is required.
Eg: parcel.

6.
Tree Shaking is an optimization technique used in JS bundlers like parcel to eliminate the unused code from the final bundle, reducing the size and improving the load times.
Tree shaking works best with the ES6 module syntax like import and export but it struggles with CommonJS because it is dynamic and harder to analyze statically.

7.
Hot Module Replacement is a feature in modern JS bundlers like Parcel which allows the developer to update modules in the application while it is running without requiring a full page refresh. This speeds up development by preserving the state of the application while applying the changes.
The bundler watches the source file for the file changes, when a file is updated the bundler recompiles only that module.

8.
The five useful features of parcel are 
a. Zero Configuration.
b. Blazing Fast Performance.
c. Automatic Transformers.
d. Built in Development server with Hot Module Replacement.
e. Code splitting and Optimized Production Builds.

a. Zero Configuration:
Parcel is designed to work without requiring any configuration files. Other bundlers require a complex setup but parcel automatically detects and processes the files whether they are JavaScript, CSS, HTML and Images.

b. Blazing Fast Performance:
Parcel is optimized for its speed. It uses multi-core processing and caching to rebuild the project almost instantly when a new change is made.
The .parcel-cache directory stores processed files, so Parcel only rebuilds what’s necessary.

d. Built in Development server with Hot Module Replacement:
When the parcel is initiated, it starts a local server and automatically opens the default web browser on the system. With Hot Module Replacement, the code changes could be made and parcel updates the browser instantly without requiring a full page refresh.



9.
The .gitignore file is an environment text file in the git repository that tells Git which files of the directory to ignore and not to track in the version control.
The files which are to be added in the .gitignore file are:
a. API keys/ environment files in the project.
b. The node_modules which are generated in the project folder.
c. The package-lock.json file.
d. The cache files like .parcel-cache/ and the IDE folders like .vscode/ .

The files which are not to be added in the .gitignore file are:
a. The package.json file which contains all the information about the project.
b. The source code files and component files which are required for the project to run.
c. The shared license and the readme files.

10.
package.json:
It is used to define the project’s metadata.
It lists the packages on which the project is dependent on(both the dependencies and devDependencies).
It includes the scripts for running tasks and project details like the name, version, script and configuration.
It uses semantic versioning (^19.2.0 or ~19.2.0) to specify dependency ranges
This file is shared across all environments.

package-lock.json:
It locks the exact versions of all dependencies and sub-dependencies installed in the project.
It prevents unexpected updates or version conflicts.
It ensures consistent installations across all environments.
If this file is deleted also once again after installing the project using “npm install”, the file gets regenerated as the base for the package-lock.json is package.json .



11.
package-lock.json is auto-generated by npm to ensure consistent dependency versions across all environments. Manually editing it can introduce version mismatches or corrupt the dependency tree, leading to: Build failures. Runtime errors. Unexpected behavior in production.
package-lock.json contains a detailed hierarchy of all dependencies and sub-dependencies. Manually editing it can disrupt this hierarchy, leading to: Missing or duplicate dependencies. Conflicts between package versions.
The package-lock.json file helps protect against malicious or compromised packages by locking versions and verifying integrity. Manual edits can bypass these safeguards, exposing your project to security vulnerabilities.

12.
node_modules is a directory created by npm (Node Package Manager) when you install dependencies for your Node.js project. It contains: All the JavaScript packages (libraries, frameworks, tools) your project depends on. Sub-dependencies (packages required by your dependencies). Executable scripts and binaries for tools like Babel.
This node_modules folder should almost never push to git as:
Huge Repository Size: node_modules can be extremely large (often hundreds of MB or even GB). This makes your repository slow to clone, pull, or push.
Redundant and Unnecessary: node_modules can be regenerated at any time by running npm install.
Platform-Specific Files: Some packages include binaries or platform-specific files (e.g., for macOS, Windows, or Linux). Pushing these to Git can cause conflicts or errors when used on a different platform.

13.

The dist folder (short for "distribution") is a standard directory in many web projects where the final, optimized, and production-ready version of your application is built. It contains all the files needed to deploy and run your app in production, such as:


Minified and bundled JavaScript (e.g., bundle.js).
Compiled CSS (e.g., styles.css).
Static assets (e.g., images, fonts, HTML files).
Transpiled code (e.g., TypeScript compiled to JavaScript, modern JavaScript converted to ES5 for broader browser compatibility).
This dist folder is also generally not pushed to git.

14.
Browserslist is a configuration tool used in npm-based projects to specify which browsers and versions the code should support. It helps tools like Autoprefixer, Babel, optimize the code for compatibility with specific browsers.
When you define a Browserslist configuration in the project (e.g., in package.json or .browserslistrc), tools like Autoprefixer and Babel use it to:
Add CSS vendor prefixes 
Transpile modern JavaScript to older versions.
Optimize your code for only the browsers you care about.

15.
^ - caret:
The caret symbol allows updates to the minor and patch versions, but not the major version. 
For example, ^1.2.3 would allow versions like 1.2.4, 1.3.0, or 1.9.9, but it would not allow 2.0.0.
~ - tilde:
The tilde symbol allows updates only to the patch version, maintaining the specified major and minor versions. 
For example, ~1.2.3 would allow versions like 1.2.4, 1.2.5, but it would not allow 1.3.0 or 2.0.0.
